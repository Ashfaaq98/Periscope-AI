from flask import Flask , render_template , send_file, request , jsonify
import pickle
from flask_wtf import FlaskForm
from wtforms import FileField, SubmitField
from werkzeug.utils import secure_filename
import os
from wtforms.validators import InputRequired
import numpy
import re
from keras.preprocessing.sequence import pad_sequences
from keras.models import load_model
import warnings
warnings.filterwarnings("ignore")
import pdfresults


# create flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'supersecretkey'
app.config['UPLOAD_FOLDER'] = 'static/files'

# Create File Form Class
class UploadFileForm(FlaskForm):
    file = FileField("File", validators=[InputRequired()])
    submit = SubmitField("Upload File")

# Define Landing Page
@app.route("/",methods=['GET',"POST"])
def home():
    form = UploadFileForm()
    
    return render_template('index.html', form=form)

# Define API Function
@app.route('/API', methods=['POST'])
def process_file():

    if 'file' not in request.files:
        return 'No file provided in the request', 400

    uploaded_file = request.files['file']
    if uploaded_file.filename == '':
        return 'Empty file provided in the request', 400
    
    # Save the file reeieved from the API request
    dir = os.path.dirname(__file__)
    uploaded_file.save(os.path.join(os.path.abspath(dir),app.config['UPLOAD_FOLDER'],secure_filename(uploaded_file.filename)))
   
    nam = os.path.join(dir,app.config['UPLOAD_FOLDER'],uploaded_file.filename)
    s = 'saved_detector.pkl'
    m = os.path.join(dir,s)
   
    with open(m ,"rb" ) as saved_detector:
        classifier, hasher = pickle.load(saved_detector)

    features = get_string_features(nam,hasher)
    z = features.reshape(1,-1)
    result_proba = classifier.predict_proba(z)[:,1]

    if result_proba > 0.5:
        response_data = {
        'status': 'Malware',
    }
        
        return jsonify(response_data)
    
    else:
        response_data = {
        'status': 'Benign',
    }
        
        return jsonify(response_data)

## Define Results Page
@app.route("/results", methods=['GET',"POST"])
def results():

    dir = os.path.dirname(__file__)
    form = UploadFileForm()
    if form.validate_on_submit():
        file = form.file.data # First grab the file
        file.save(os.path.join(os.path.abspath(dir),app.config['UPLOAD_FOLDER'],secure_filename(file.filename))) # Then save the file
        
    name = os.path.join(dir,app.config['UPLOAD_FOLDER'],file.filename)
    s = 'saved_detector.pkl'
    m = os.path.join(dir,s)
   
    with open(m ,"rb" ) as saved_detector:
        classifier, hasher = pickle.load(saved_detector)

    features = get_string_features(name,hasher)
    z = features.reshape(1,-1)
    result_proba = classifier.predict_proba(z)[:,1]
   
    if result_proba > 0.7:
        res = "Malicious"
        file_path = pdfresults.create_pdf(name)
        return send_file(file_path, as_attachment=False, download_name='Malware-Analysis-result.pdf')
    
    elif result_proba > 0.5 and result_proba < 0.7:
        res = kerasmodel(name)
        file_path = pdfresults.create_pdf(name)
        return send_file(file_path, as_attachment=False, download_name='Malware-Analysis-result.pdf')
    
    else:
        res = "Benign"
        return render_template('results.html', pred='Result {}'.format(res))

## Remaining of the code defines the functions

# Function to use the deep learning keras model to detect Malware
def kerasmodel(name):

    model = load_model('./deepmalware.h5')

    with open("./tokenizer.pkl","rb") as token:
            tokenizer = pickle.load(token)

    with open("./pad-sequence.pkl","rb") as seq:
            max_sequence_length = pickle.load(seq)

    # Read new files
    new_texts = read_files(name)  # Label is not used for prediction

    # Tokenize and pad sequences for new data
    new_sequences = tokenizer.texts_to_sequences(new_texts)
    new_data = pad_sequences(new_sequences, maxlen=max_sequence_length)

    # Make predictions
    predictions = model.predict(new_data)
    print(predictions)

    if predictions > 0.5:
         pred = "Malicious"
    else:
         pred = "Benign"

    return pred

# Function to extract string features used by the Decision Tree Model
def get_string_features(name,hasher):
    # extract strings from binary file using regular expressions
    chars = r" -~"
    min_length = 5
    string_regexp = '[%s]{%d,}' % (chars, min_length)
    file_object = open(name,encoding="ISO-8859-1")
    data = file_object.read()
    pattern = re.compile(string_regexp)
    strings = pattern.findall(data)

    # store string features in dictionary form
    string_features = {}
    for string in strings:
        string_features[string] = 1

    # hash the features using the hashing trick
    hashed_features = hasher.transform([string_features])

    # do some data munging to get the feature array
    hashed_features = hashed_features.todense()
    hashed_features = numpy.asarray(hashed_features)
    hashed_features = hashed_features[0]

    # return hashed string features
    print("Extracted {0} strings from {1}".format(len(string_features),name))
    return hashed_features

## Function to extract strings from binary used by the keras model
def read_files(name):
        
    texts = []
    chars = r" -~"
    min_length = 5
    string_regexp = '[%s]{%d,}' % (chars, min_length)

    with open(name, 'r', encoding="ISO-8859-1") as file:
            text = file.read()
            pattern = re.compile(string_regexp)
            strings = pattern.findall(text)
            texts.append(strings)
            
    return texts


if __name__ == "__main__":
    app.run(debug=True)

